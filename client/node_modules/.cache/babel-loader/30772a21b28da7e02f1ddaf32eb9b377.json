{"ast":null,"code":"import { __assign, __extends, __rest } from \"tslib\";\nimport * as React from 'react';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\nimport { parser } from \"../parser/index.js\";\nimport { Mutation } from \"../components/index.js\";\nimport { defaultMapPropsToOptions, getDisplayName, calculateVariablesFromProps, GraphQLBase } from \"./hoc-utils.js\";\nexport function withMutation(document, operationOptions) {\n  if (operationOptions === void 0) {\n    operationOptions = {};\n  }\n\n  var operation = parser(document);\n  var _a = operationOptions.options,\n      options = _a === void 0 ? defaultMapPropsToOptions : _a,\n      _b = operationOptions.alias,\n      alias = _b === void 0 ? 'Apollo' : _b;\n  var mapPropsToOptions = options;\n  if (typeof mapPropsToOptions !== 'function') mapPropsToOptions = function mapPropsToOptions() {\n    return options;\n  };\n  return function (WrappedComponent) {\n    var graphQLDisplayName = alias + \"(\" + getDisplayName(WrappedComponent) + \")\";\n\n    var GraphQL = function (_super) {\n      __extends(GraphQL, _super);\n\n      function GraphQL() {\n        return _super !== null && _super.apply(this, arguments) || this;\n      }\n\n      GraphQL.prototype.render = function () {\n        var props = this.props;\n        var opts = mapPropsToOptions(props);\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props);\n        }\n\n        return React.createElement(Mutation, __assign({\n          ignoreResults: true\n        }, opts, {\n          mutation: document\n        }), function (mutate, _a) {\n          var _b, _c;\n\n          var data = _a.data,\n              r = __rest(_a, [\"data\"]);\n\n          var result = Object.assign(r, data || {});\n          var name = operationOptions.name || 'mutate';\n          var resultName = operationOptions.name ? name + \"Result\" : 'result';\n          var childProps = (_b = {}, _b[name] = mutate, _b[resultName] = result, _b);\n\n          if (operationOptions.props) {\n            var newResult = (_c = {}, _c[name] = mutate, _c[resultName] = result, _c.ownProps = props, _c);\n            childProps = operationOptions.props(newResult);\n          }\n\n          return React.createElement(WrappedComponent, __assign({}, props, childProps));\n        });\n      };\n\n      GraphQL.displayName = graphQLDisplayName;\n      GraphQL.WrappedComponent = WrappedComponent;\n      return GraphQL;\n    }(GraphQLBase);\n\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}","map":{"version":3,"sources":["../../../src/react/hoc/mutation-hoc.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { DocumentNode } from 'graphql';\nimport hoistNonReactStatics from 'hoist-non-react-statics';\n\nimport { parser } from '../parser';\nimport { DefaultContext } from '../../core/types';\nimport {\n  BaseMutationOptions,\n  MutationFunction,\n  MutationResult\n} from '../types/types';\nimport { Mutation } from '../components';\n\nimport {\n  defaultMapPropsToOptions,\n  getDisplayName,\n  calculateVariablesFromProps,\n  GraphQLBase\n} from './hoc-utils';\nimport { OperationOption, OptionProps, MutateProps } from './types';\nimport { ApolloCache } from '../../core';\n\nexport function withMutation<\n  TProps extends TGraphQLVariables | {} = {},\n  TData extends Record<string, any> = {},\n  TGraphQLVariables = {},\n  TChildProps = MutateProps<TData, TGraphQLVariables>,\n  TContext = DefaultContext,\n  TCache extends ApolloCache<any> = ApolloCache<any>,\n>(\n  document: DocumentNode,\n  operationOptions: OperationOption<\n    TProps,\n    TData,\n    TGraphQLVariables,\n    TChildProps\n  > = {}\n) {\n  // this is memoized so if coming from `graphql` there is nearly no extra cost\n  const operation = parser(document);\n  // extract options\n\n  const {\n    options = defaultMapPropsToOptions,\n    alias = 'Apollo'\n  } = operationOptions;\n\n  let mapPropsToOptions = options as (props: any) => BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n  if (typeof mapPropsToOptions !== 'function')\n    mapPropsToOptions = () => options as BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n\n  return (\n    WrappedComponent: React.ComponentType<TProps & TChildProps>\n  ): React.ComponentClass<TProps> => {\n    const graphQLDisplayName = `${alias}(${getDisplayName(WrappedComponent)})`;\n    class GraphQL extends GraphQLBase<TProps, TChildProps> {\n      static displayName = graphQLDisplayName;\n      static WrappedComponent = WrappedComponent;\n      render() {\n        let props = this.props as TProps;\n        const opts = mapPropsToOptions(props) as BaseMutationOptions<TData, TGraphQLVariables, TContext, TCache>;\n\n        if (operationOptions.withRef) {\n          this.withRef = true;\n          props = Object.assign({}, props, {\n            ref: this.setWrappedInstance\n          });\n        }\n        if (!opts.variables && operation.variables.length > 0) {\n          opts.variables = calculateVariablesFromProps(operation, props) as TGraphQLVariables;\n        }\n\n        return (\n          <Mutation ignoreResults {...opts} mutation={document}>\n            {(\n              mutate: MutationFunction<TData, TGraphQLVariables>,\n              { data, ...r }: MutationResult<TData>\n            ) => {\n              // the HOC's historically hoisted the data from the execution result\n              // up onto the result since it was passed as a nested prop\n              // we massage the Mutation component's shape here to replicate that\n              // this matches the query HoC\n              const result = Object.assign(r, data || {});\n              const name = operationOptions.name || 'mutate';\n              const resultName = operationOptions.name\n                ? `${name}Result`\n                : 'result';\n              let childProps = ({\n                [name]: mutate,\n                [resultName]: result\n              } as any) as TChildProps;\n              if (operationOptions.props) {\n                const newResult: OptionProps<\n                  TProps,\n                  TData,\n                  TGraphQLVariables\n                > = {\n                  [name]: mutate,\n                  [resultName]: result,\n                  ownProps: props\n                };\n                childProps = operationOptions.props(newResult) as any;\n              }\n\n              return <WrappedComponent {...props} {...childProps} />;\n            }}\n          </Mutation>\n        );\n      }\n    }\n\n    // Make sure we preserve any custom statics on the original component.\n    return hoistNonReactStatics(GraphQL, WrappedComponent, {});\n  };\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}