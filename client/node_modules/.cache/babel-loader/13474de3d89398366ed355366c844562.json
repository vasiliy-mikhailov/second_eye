{"ast":null,"code":"import naturalCompare from \"./naturalCompare.mjs\";\n/**\r\n * Given an invalid input string and a list of valid options, returns a filtered\r\n * list of valid options sorted based on their similarity with the input.\r\n */\n\nexport default function suggestionList(input, options) {\n  var optionsByDistance = Object.create(null);\n  var lexicalDistance = new LexicalDistance(input);\n  var threshold = Math.floor(input.length * 0.4) + 1;\n\n  for (var _i2 = 0; _i2 < options.length; _i2++) {\n    var option = options[_i2];\n    var distance = lexicalDistance.measure(option, threshold);\n\n    if (distance !== undefined) {\n      optionsByDistance[option] = distance;\n    }\n  }\n\n  return Object.keys(optionsByDistance).sort(function (a, b) {\n    var distanceDiff = optionsByDistance[a] - optionsByDistance[b];\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\n  });\n}\n/**\r\n * Computes the lexical distance between strings A and B.\r\n *\r\n * The \"distance\" between two strings is given by counting the minimum number\r\n * of edits needed to transform string A into string B. An edit can be an\r\n * insertion, deletion, or substitution of a single character, or a swap of two\r\n * adjacent characters.\r\n *\r\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\r\n * as a single edit which helps identify mis-cased values with an edit distance\r\n * of 1.\r\n *\r\n * This distance can be useful for detecting typos in input or sorting\r\n */\n\nvar LexicalDistance = /*#__PURE__*/function () {\n  function LexicalDistance(input) {\n    this._input = input;\n    this._inputLowerCase = input.toLowerCase();\n    this._inputArray = stringToArray(this._inputLowerCase);\n    this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];\n  }\n\n  var _proto = LexicalDistance.prototype;\n\n  _proto.measure = function measure(option, threshold) {\n    if (this._input === option) {\n      return 0;\n    }\n\n    var optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\n\n    if (this._inputLowerCase === optionLowerCase) {\n      return 1;\n    }\n\n    var a = stringToArray(optionLowerCase);\n    var b = this._inputArray;\n\n    if (a.length < b.length) {\n      var tmp = a;\n      a = b;\n      b = tmp;\n    }\n\n    var aLength = a.length;\n    var bLength = b.length;\n\n    if (aLength - bLength > threshold) {\n      return undefined;\n    }\n\n    var rows = this._rows;\n\n    for (var j = 0; j <= bLength; j++) {\n      rows[0][j] = j;\n    }\n\n    for (var i = 1; i <= aLength; i++) {\n      var upRow = rows[(i - 1) % 3];\n      var currentRow = rows[i % 3];\n      var smallestCell = currentRow[0] = i;\n\n      for (var _j = 1; _j <= bLength; _j++) {\n        var cost = a[i - 1] === b[_j - 1] ? 0 : 1;\n        var currentCell = Math.min(upRow[_j] + 1, // delete\n        currentRow[_j - 1] + 1, // insert\n        upRow[_j - 1] + cost // substitute\n        );\n\n        if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {\n          // transposition\n          var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\n        }\n\n        if (currentCell < smallestCell) {\n          smallestCell = currentCell;\n        }\n\n        currentRow[_j] = currentCell;\n      } // Early exit, since distance can't go smaller than smallest element of the previous row.\n\n\n      if (smallestCell > threshold) {\n        return undefined;\n      }\n    }\n\n    var distance = rows[aLength % 3][bLength];\n    return distance <= threshold ? distance : undefined;\n  };\n\n  return LexicalDistance;\n}();\n\nfunction stringToArray(str) {\n  var strLength = str.length;\n  var array = new Array(strLength);\n\n  for (var i = 0; i < strLength; ++i) {\n    array[i] = str.charCodeAt(i);\n  }\n\n  return array;\n}","map":{"version":3,"sources":["C:/Users/mikhaylovv/PycharmProjects/second_eye/client/node_modules/graphql/jsutils/suggestionList.mjs"],"names":["naturalCompare","suggestionList","input","options","optionsByDistance","Object","create","lexicalDistance","LexicalDistance","threshold","Math","floor","length","_i2","option","distance","measure","undefined","keys","sort","a","b","distanceDiff","_input","_inputLowerCase","toLowerCase","_inputArray","stringToArray","_rows","Array","fill","_proto","prototype","optionLowerCase","tmp","aLength","bLength","rows","j","i","upRow","currentRow","smallestCell","_j","cost","currentCell","min","doubleDiagonalCell","str","strLength","array","charCodeAt"],"mappings":"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","sourcesContent":["import naturalCompare from \"./naturalCompare.mjs\";\r\n/**\r\n * Given an invalid input string and a list of valid options, returns a filtered\r\n * list of valid options sorted based on their similarity with the input.\r\n */\r\n\r\nexport default function suggestionList(input, options) {\r\n  var optionsByDistance = Object.create(null);\r\n  var lexicalDistance = new LexicalDistance(input);\r\n  var threshold = Math.floor(input.length * 0.4) + 1;\r\n\r\n  for (var _i2 = 0; _i2 < options.length; _i2++) {\r\n    var option = options[_i2];\r\n    var distance = lexicalDistance.measure(option, threshold);\r\n\r\n    if (distance !== undefined) {\r\n      optionsByDistance[option] = distance;\r\n    }\r\n  }\r\n\r\n  return Object.keys(optionsByDistance).sort(function (a, b) {\r\n    var distanceDiff = optionsByDistance[a] - optionsByDistance[b];\r\n    return distanceDiff !== 0 ? distanceDiff : naturalCompare(a, b);\r\n  });\r\n}\r\n/**\r\n * Computes the lexical distance between strings A and B.\r\n *\r\n * The \"distance\" between two strings is given by counting the minimum number\r\n * of edits needed to transform string A into string B. An edit can be an\r\n * insertion, deletion, or substitution of a single character, or a swap of two\r\n * adjacent characters.\r\n *\r\n * Includes a custom alteration from Damerau-Levenshtein to treat case changes\r\n * as a single edit which helps identify mis-cased values with an edit distance\r\n * of 1.\r\n *\r\n * This distance can be useful for detecting typos in input or sorting\r\n */\r\n\r\nvar LexicalDistance = /*#__PURE__*/function () {\r\n  function LexicalDistance(input) {\r\n    this._input = input;\r\n    this._inputLowerCase = input.toLowerCase();\r\n    this._inputArray = stringToArray(this._inputLowerCase);\r\n    this._rows = [new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0), new Array(input.length + 1).fill(0)];\r\n  }\r\n\r\n  var _proto = LexicalDistance.prototype;\r\n\r\n  _proto.measure = function measure(option, threshold) {\r\n    if (this._input === option) {\r\n      return 0;\r\n    }\r\n\r\n    var optionLowerCase = option.toLowerCase(); // Any case change counts as a single edit\r\n\r\n    if (this._inputLowerCase === optionLowerCase) {\r\n      return 1;\r\n    }\r\n\r\n    var a = stringToArray(optionLowerCase);\r\n    var b = this._inputArray;\r\n\r\n    if (a.length < b.length) {\r\n      var tmp = a;\r\n      a = b;\r\n      b = tmp;\r\n    }\r\n\r\n    var aLength = a.length;\r\n    var bLength = b.length;\r\n\r\n    if (aLength - bLength > threshold) {\r\n      return undefined;\r\n    }\r\n\r\n    var rows = this._rows;\r\n\r\n    for (var j = 0; j <= bLength; j++) {\r\n      rows[0][j] = j;\r\n    }\r\n\r\n    for (var i = 1; i <= aLength; i++) {\r\n      var upRow = rows[(i - 1) % 3];\r\n      var currentRow = rows[i % 3];\r\n      var smallestCell = currentRow[0] = i;\r\n\r\n      for (var _j = 1; _j <= bLength; _j++) {\r\n        var cost = a[i - 1] === b[_j - 1] ? 0 : 1;\r\n        var currentCell = Math.min(upRow[_j] + 1, // delete\r\n        currentRow[_j - 1] + 1, // insert\r\n        upRow[_j - 1] + cost // substitute\r\n        );\r\n\r\n        if (i > 1 && _j > 1 && a[i - 1] === b[_j - 2] && a[i - 2] === b[_j - 1]) {\r\n          // transposition\r\n          var doubleDiagonalCell = rows[(i - 2) % 3][_j - 2];\r\n          currentCell = Math.min(currentCell, doubleDiagonalCell + 1);\r\n        }\r\n\r\n        if (currentCell < smallestCell) {\r\n          smallestCell = currentCell;\r\n        }\r\n\r\n        currentRow[_j] = currentCell;\r\n      } // Early exit, since distance can't go smaller than smallest element of the previous row.\r\n\r\n\r\n      if (smallestCell > threshold) {\r\n        return undefined;\r\n      }\r\n    }\r\n\r\n    var distance = rows[aLength % 3][bLength];\r\n    return distance <= threshold ? distance : undefined;\r\n  };\r\n\r\n  return LexicalDistance;\r\n}();\r\n\r\nfunction stringToArray(str) {\r\n  var strLength = str.length;\r\n  var array = new Array(strLength);\r\n\r\n  for (var i = 0; i < strLength; ++i) {\r\n    array[i] = str.charCodeAt(i);\r\n  }\r\n\r\n  return array;\r\n}\r\n"]},"metadata":{},"sourceType":"module"}