{"ast":null,"code":"import { __extends } from \"tslib\";\nimport * as React from 'react';\nimport { invariant } from 'ts-invariant';\nexport var defaultMapPropsToOptions = function () {\n  return {};\n};\nexport var defaultMapResultToProps = function (props) {\n  return props;\n};\nexport var defaultMapPropsToSkip = function () {\n  return false;\n};\nexport function getDisplayName(WrappedComponent) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\nexport function calculateVariablesFromProps(operation, props) {\n  var variables = {};\n\n  for (var _i = 0, _a = operation.variables; _i < _a.length; _i++) {\n    var _b = _a[_i],\n        variable = _b.variable,\n        type = _b.type;\n    if (!variable.name || !variable.name.value) continue;\n    var variableName = variable.name.value;\n    var variableProp = props[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n\n  return variables;\n}\n\nvar GraphQLBase = function (_super) {\n  __extends(GraphQLBase, _super);\n\n  function GraphQLBase(props) {\n    var _this = _super.call(this, props) || this;\n\n    _this.withRef = false;\n    _this.setWrappedInstance = _this.setWrappedInstance.bind(_this);\n    return _this;\n  }\n\n  GraphQLBase.prototype.getWrappedInstance = function () {\n    __DEV__ ? invariant(this.withRef, \"To access the wrapped instance, you need to specify \" + \"{ withRef: true } in the options\") : invariant(this.withRef, 34);\n    return this.wrappedInstance;\n  };\n\n  GraphQLBase.prototype.setWrappedInstance = function (ref) {\n    this.wrappedInstance = ref;\n  };\n\n  return GraphQLBase;\n}(React.Component);\n\nexport { GraphQLBase };","map":{"version":3,"sources":["../../../src/react/hoc/hoc-utils.tsx"],"names":[],"mappings":";AAAA,OAAO,KAAK,KAAZ,MAAuB,OAAvB;AACA,SAAS,SAAT,QAA0B,cAA1B;AAIA,OAAO,IAAM,wBAAwB,GAAG,YAAA;AAAM,SAAA,EAAA;AAAI,CAA3C;AACP,OAAO,IAAM,uBAAuB,GAAuB,UAAA,KAAA,EAAK;AAAI,SAAA,KAAA;AAAK,CAAlE;AACP,OAAO,IAAM,qBAAqB,GAAG,YAAA;AAAM,SAAA,KAAA;AAAK,CAAzC;AAEP,OAAM,SAAU,cAAV,CAA4B,gBAA5B,EAAoE;AACxE,SAAO,gBAAgB,CAAC,WAAjB,IAAgC,gBAAgB,CAAC,IAAjD,IAAyD,WAAhE;AACD;AAED,OAAM,SAAU,2BAAV,CACJ,SADI,EAEJ,KAFI,EAES;AAEb,MAAI,SAAS,GAAuB,EAApC;;AACA,OAA+B,IAAA,EAAA,GAAA,CAAA,EAAA,EAAA,GAAA,SAAS,CAAC,SAAzC,EAA+B,EAAA,GAAA,EAAA,CAAA,MAA/B,EAA+B,EAAA,EAA/B,EAAoD;AAA3C,QAAA,EAAA,GAAA,EAAA,CAAA,EAAA,CAAA;AAAA,QAAE,QAAQ,GAAA,EAAA,CAAA,QAAV;AAAA,QAAY,IAAI,GAAA,EAAA,CAAA,IAAhB;AACP,QAAI,CAAC,QAAQ,CAAC,IAAV,IAAkB,CAAC,QAAQ,CAAC,IAAT,CAAc,KAArC,EAA4C;AAE5C,QAAM,YAAY,GAAG,QAAQ,CAAC,IAAT,CAAc,KAAnC;AACA,QAAM,YAAY,GAAI,KAAa,CAAC,YAAD,CAAnC;;AAEA,QAAI,OAAO,YAAP,KAAwB,WAA5B,EAAyC;AACvC,MAAA,SAAS,CAAC,YAAD,CAAT,GAA0B,YAA1B;AACA;AACD;;AAGD,QAAI,IAAI,CAAC,IAAL,KAAc,aAAlB,EAAiC;AAC/B,MAAA,SAAS,CAAC,YAAD,CAAT,GAA0B,SAA1B;AACD;AACF;;AACD,SAAO,SAAP;AACD;;AAOD,IAAA,WAAA,GAAA,UAAA,MAAA,EAAA;AAIU,EAAA,SAAA,CAAA,WAAA,EAAA,MAAA,CAAA;;AAKR,WAAA,WAAA,CAAY,KAAZ,EAAyB;AAAzB,QAAA,KAAA,GACE,MAAA,CAAA,IAAA,CAAA,IAAA,EAAM,KAAN,KAAY,IADd;;AAJO,IAAA,KAAA,CAAA,OAAA,GAAmB,KAAnB;AAML,IAAA,KAAI,CAAC,kBAAL,GAA0B,KAAI,CAAC,kBAAL,CAAwB,IAAxB,CAA6B,KAA7B,CAA1B;;AACD;;AAED,EAAA,WAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,YAAA;AACE,IAAA,OAAA,GACE,SAAK,CAAA,KACL,OADK,EACL,yDACE,kCAFG,CADP,GAIE,SAAA,CAAA,KAAA,OAAA,EAAA,EAAA,CAJF;AAMA,WAAO,KAAK,eAAZ;AACD,GARD;;AAUA,EAAA,WAAA,CAAA,SAAA,CAAA,kBAAA,GAAA,UAAmB,GAAnB,EAAyD;AACvD,SAAK,eAAL,GAAuB,GAAvB;AACD,GAFD;;AAGF,SAAA,WAAA;AAAC,CA3BD,CAIU,KAAK,CAAC,SAJhB,CAAA","sourcesContent":["import * as React from 'react';\nimport { invariant } from 'ts-invariant';\nimport { OperationVariables } from '../../core';\nimport { IDocumentDefinition } from '../parser';\n\nexport const defaultMapPropsToOptions = () => ({});\nexport const defaultMapResultToProps: <P>(props: P) => P = props => props;\nexport const defaultMapPropsToSkip = () => false;\n\nexport function getDisplayName<P>(WrappedComponent: React.ComponentType<P>) {\n  return WrappedComponent.displayName || WrappedComponent.name || 'Component';\n}\n\nexport function calculateVariablesFromProps<TProps>(\n  operation: IDocumentDefinition,\n  props: TProps\n) {\n  let variables: OperationVariables = {};\n  for (let { variable, type } of operation.variables) {\n    if (!variable.name || !variable.name.value) continue;\n\n    const variableName = variable.name.value;\n    const variableProp = (props as any)[variableName];\n\n    if (typeof variableProp !== 'undefined') {\n      variables[variableName] = variableProp;\n      continue;\n    }\n\n    // Allow optional props\n    if (type.kind !== 'NonNullType') {\n      variables[variableName] = undefined;\n    }\n  }\n  return variables;\n}\n\nexport type RefSetter<TChildProps> = (\n  ref: React.ComponentClass<TChildProps>\n) => void | void;\n\n// base class for hocs to easily manage refs\nexport class GraphQLBase<\n  TProps,\n  TChildProps,\n  TState = any\n> extends React.Component<TProps, TState> {\n  public withRef: boolean = false;\n  // wrapped instance\n  private wrappedInstance?: React.ComponentClass<TChildProps>;\n\n  constructor(props: TProps) {\n    super(props);\n    this.setWrappedInstance = this.setWrappedInstance.bind(this);\n  }\n\n  getWrappedInstance() {\n    invariant(\n      this.withRef,\n      `To access the wrapped instance, you need to specify ` +\n        `{ withRef: true } in the options`\n    );\n\n    return this.wrappedInstance;\n  }\n\n  setWrappedInstance(ref: React.ComponentClass<TChildProps>) {\n    this.wrappedInstance = ref;\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}