{"ast":null,"code":"import { __extends } from \"tslib\";\nimport { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { getGlobalObject, isNativeFetch, logger, supportsReferrerPolicy, SyncPromise } from '@sentry/utils';\nimport { BaseTransport } from './base';\n/**\r\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\r\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\r\n * this chain becomes orphaned and there is no possible way to capture it's rejections\r\n * other than allowing it bubble up to this very handler. eg.\r\n *\r\n * const f = window.fetch;\r\n * window.fetch = function () {\r\n *   const p = f.apply(this, arguments);\r\n *\r\n *   p.then(function() {\r\n *     console.log('hi.');\r\n *   });\r\n *\r\n *   return p;\r\n * }\r\n *\r\n * `p.then(function () { ... })` is producing a completely separate promise chain,\r\n * however, what's returned is `p` - the result of original `fetch` call.\r\n *\r\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\r\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\r\n * effectively causing another event to be captured.\r\n * This makes a whole process become an infinite loop, which we need to somehow\r\n * deal with, and break it in one way or another.\r\n *\r\n * To deal with this issue, we are making sure that we _always_ use the real\r\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\r\n * The only downside to this would be missing our own requests as breadcrumbs,\r\n * but because we are already not doing this, it should be just fine.\r\n *\r\n * Possible failed fetch error messages per-browser:\r\n *\r\n * Chrome:  Failed to fetch\r\n * Edge:    Failed to Fetch\r\n * Firefox: NetworkError when attempting to fetch resource\r\n * Safari:  resource blocked by content blocker\r\n */\n\nfunction getNativeFetchImplementation() {\n  /* eslint-disable @typescript-eslint/unbound-method */\n  var _a, _b; // Fast path to avoid DOM I/O\n\n\n  var global = getGlobalObject();\n\n  if (isNativeFetch(global.fetch)) {\n    return global.fetch.bind(global);\n  }\n\n  var document = global.document;\n  var fetchImpl = global.fetch; // eslint-disable-next-line deprecation/deprecation\n\n  if (typeof ((_a = document) === null || _a === void 0 ? void 0 : _a.createElement) === \"function\") {\n    try {\n      var sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n\n      if ((_b = sandbox.contentWindow) === null || _b === void 0 ? void 0 : _b.fetch) {\n        fetchImpl = sandbox.contentWindow.fetch;\n      }\n\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return fetchImpl.bind(global);\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n/** `fetch` based transport */\n\n\nvar FetchTransport = function (_super) {\n  __extends(FetchTransport, _super);\n\n  function FetchTransport(options, fetchImpl) {\n    if (fetchImpl === void 0) {\n      fetchImpl = getNativeFetchImplementation();\n    }\n\n    var _this = _super.call(this, options) || this;\n\n    _this._fetch = fetchImpl;\n    return _this;\n  }\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  FetchTransport.prototype.sendEvent = function (event) {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  };\n  /**\r\n   * @inheritDoc\r\n   */\n\n\n  FetchTransport.prototype.sendSession = function (session) {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  };\n  /**\r\n   * @param sentryRequest Prepared SentryRequest to be delivered\r\n   * @param originalPayload Original payload used to create SentryRequest\r\n   */\n\n\n  FetchTransport.prototype._sendRequest = function (sentryRequest, originalPayload) {\n    var _this = this;\n\n    if (this._isRateLimited(sentryRequest.type)) {\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        reason: \"Transport for \" + sentryRequest.type + \" requests locked till \" + this._disabledUntil(sentryRequest.type) + \" due to too many requests.\",\n        status: 429\n      });\n    }\n\n    var options = {\n      body: sentryRequest.body,\n      method: 'POST',\n      // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default\n      // https://caniuse.com/#feat=referrer-policy\n      // It doesn't. And it throw exception instead of ignoring this parameter...\n      // REF: https://github.com/getsentry/raven-js/issues/1233\n      referrerPolicy: supportsReferrerPolicy() ? 'origin' : ''\n    };\n\n    if (this.options.fetchParameters !== undefined) {\n      Object.assign(options, this.options.fetchParameters);\n    }\n\n    if (this.options.headers !== undefined) {\n      options.headers = this.options.headers;\n    }\n\n    return this._buffer.add(function () {\n      return new SyncPromise(function (resolve, reject) {\n        void _this._fetch(sentryRequest.url, options).then(function (response) {\n          var headers = {\n            'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n            'retry-after': response.headers.get('Retry-After')\n          };\n\n          _this._handleResponse({\n            requestType: sentryRequest.type,\n            response: response,\n            headers: headers,\n            resolve: resolve,\n            reject: reject\n          });\n        }).catch(reject);\n      });\n    });\n  };\n\n  return FetchTransport;\n}(BaseTransport);\n\nexport { FetchTransport };","map":{"version":3,"sources":["../../src/transports/fetch.ts"],"names":[],"mappings":"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","sourcesContent":["import { eventToSentryRequest, sessionToSentryRequest } from '@sentry/core';\nimport { Event, Response, SentryRequest, Session, TransportOptions } from '@sentry/types';\nimport { getGlobalObject, isNativeFetch, logger, supportsReferrerPolicy, SyncPromise } from '@sentry/utils';\n\nimport { BaseTransport } from './base';\n\ntype FetchImpl = typeof fetch;\n\n/**\n * A special usecase for incorrectly wrapped Fetch APIs in conjunction with ad-blockers.\n * Whenever someone wraps the Fetch API and returns the wrong promise chain,\n * this chain becomes orphaned and there is no possible way to capture it's rejections\n * other than allowing it bubble up to this very handler. eg.\n *\n * const f = window.fetch;\n * window.fetch = function () {\n *   const p = f.apply(this, arguments);\n *\n *   p.then(function() {\n *     console.log('hi.');\n *   });\n *\n *   return p;\n * }\n *\n * `p.then(function () { ... })` is producing a completely separate promise chain,\n * however, what's returned is `p` - the result of original `fetch` call.\n *\n * This mean, that whenever we use the Fetch API to send our own requests, _and_\n * some ad-blocker blocks it, this orphaned chain will _always_ reject,\n * effectively causing another event to be captured.\n * This makes a whole process become an infinite loop, which we need to somehow\n * deal with, and break it in one way or another.\n *\n * To deal with this issue, we are making sure that we _always_ use the real\n * browser Fetch API, instead of relying on what `window.fetch` exposes.\n * The only downside to this would be missing our own requests as breadcrumbs,\n * but because we are already not doing this, it should be just fine.\n *\n * Possible failed fetch error messages per-browser:\n *\n * Chrome:  Failed to fetch\n * Edge:    Failed to Fetch\n * Firefox: NetworkError when attempting to fetch resource\n * Safari:  resource blocked by content blocker\n */\nfunction getNativeFetchImplementation(): FetchImpl {\n  /* eslint-disable @typescript-eslint/unbound-method */\n\n  // Fast path to avoid DOM I/O\n  const global = getGlobalObject<Window>();\n  if (isNativeFetch(global.fetch)) {\n    return global.fetch.bind(global);\n  }\n\n  const document = global.document;\n  let fetchImpl = global.fetch;\n  // eslint-disable-next-line deprecation/deprecation\n  if (typeof document?.createElement === `function`) {\n    try {\n      const sandbox = document.createElement('iframe');\n      sandbox.hidden = true;\n      document.head.appendChild(sandbox);\n      if (sandbox.contentWindow?.fetch) {\n        fetchImpl = sandbox.contentWindow.fetch;\n      }\n      document.head.removeChild(sandbox);\n    } catch (e) {\n      logger.warn('Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ', e);\n    }\n  }\n\n  return fetchImpl.bind(global);\n  /* eslint-enable @typescript-eslint/unbound-method */\n}\n\n/** `fetch` based transport */\nexport class FetchTransport extends BaseTransport {\n  /**\n   * Fetch API reference which always points to native browser implementation.\n   */\n  private _fetch: typeof fetch;\n\n  public constructor(options: TransportOptions, fetchImpl: FetchImpl = getNativeFetchImplementation()) {\n    super(options);\n    this._fetch = fetchImpl;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendEvent(event: Event): PromiseLike<Response> {\n    return this._sendRequest(eventToSentryRequest(event, this._api), event);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public sendSession(session: Session): PromiseLike<Response> {\n    return this._sendRequest(sessionToSentryRequest(session, this._api), session);\n  }\n\n  /**\n   * @param sentryRequest Prepared SentryRequest to be delivered\n   * @param originalPayload Original payload used to create SentryRequest\n   */\n  private _sendRequest(sentryRequest: SentryRequest, originalPayload: Event | Session): PromiseLike<Response> {\n    if (this._isRateLimited(sentryRequest.type)) {\n      return Promise.reject({\n        event: originalPayload,\n        type: sentryRequest.type,\n        reason: `Transport for ${sentryRequest.type} requests locked till ${this._disabledUntil(\n          sentryRequest.type,\n        )} due to too many requests.`,\n        status: 429,\n      });\n    }\n\n    const options: RequestInit = {\n      body: sentryRequest.body,\n      method: 'POST',\n      // Despite all stars in the sky saying that Edge supports old draft syntax, aka 'never', 'always', 'origin' and 'default\n      // https://caniuse.com/#feat=referrer-policy\n      // It doesn't. And it throw exception instead of ignoring this parameter...\n      // REF: https://github.com/getsentry/raven-js/issues/1233\n      referrerPolicy: (supportsReferrerPolicy() ? 'origin' : '') as ReferrerPolicy,\n    };\n    if (this.options.fetchParameters !== undefined) {\n      Object.assign(options, this.options.fetchParameters);\n    }\n    if (this.options.headers !== undefined) {\n      options.headers = this.options.headers;\n    }\n\n    return this._buffer.add(\n      () =>\n        new SyncPromise<Response>((resolve, reject) => {\n          void this._fetch(sentryRequest.url, options)\n            .then(response => {\n              const headers = {\n                'x-sentry-rate-limits': response.headers.get('X-Sentry-Rate-Limits'),\n                'retry-after': response.headers.get('Retry-After'),\n              };\n              this._handleResponse({\n                requestType: sentryRequest.type,\n                response,\n                headers,\n                resolve,\n                reject,\n              });\n            })\n            .catch(reject);\n        }),\n    );\n  }\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}